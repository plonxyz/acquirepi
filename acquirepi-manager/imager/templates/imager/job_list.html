{% extends 'imager/base.html' %}

{% block title %}Jobs - acquirepi Manager{% endblock %}

{% block content %}
<div class="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
    <h1 class="h2">Imaging Jobs</h1>
    <div class="btn-toolbar mb-2 mb-md-0">
        <a href="{% url 'job_create' %}" class="btn btn-sm btn-primary">
            <i class="bi bi-plus-circle"></i> Create New Job
        </a>
    </div>
</div>

<div class="table-responsive">
    <table class="table table-striped table-hover">
        <thead>
            <tr>
                <th>ID</th>
                <th>Agent</th>
                <th>Case Number</th>
                <th>Evidence Number</th>
                <th>Method</th>
                <th>Status</th>
                <th>Progress</th>
                <th>Created</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody>
            {% for job in jobs %}
            <tr data-job-id="{{ job.id }}">
                <td><a href="{% url 'job_detail' job.id %}">#{{ job.id }}</a></td>
                <td>{{ job.agent.hostname }}</td>
                <td>{{ job.case_number }}</td>
                <td>{{ job.evidence_number }}</td>
                <td><span class="badge bg-primary">{{ job.upload_method|upper }}</span></td>
                <td class="job-status">
                    {% if job.status == 'completed' %}
                        <span class="badge bg-success">Completed</span>
                    {% elif job.status == 'in_progress' %}
                        <span class="badge bg-info">In Progress</span>
                    {% elif job.status == 'failed' %}
                        <span class="badge bg-danger">Failed</span>
                    {% elif job.status == 'queued' %}
                        <span class="badge bg-warning">Queued</span>
                    {% else %}
                        <span class="badge bg-secondary">{{ job.status|title }}</span>
                    {% endif %}
                </td>
                <td class="job-progress">
                    <div class="progress" style="height: 20px; width: 100px;">
                        <div class="progress-bar {% if job.status == 'in_progress' %}progress-bar-striped progress-bar-animated{% endif %}"
                             role="progressbar"
                             style="width: {{ job.progress_percentage }}%;"
                             aria-valuenow="{{ job.progress_percentage }}"
                             aria-valuemin="0"
                             aria-valuemax="100">
                            {{ job.progress_percentage }}%
                        </div>
                    </div>
                </td>
                <td>{{ job.created_at|date:"Y-m-d H:i" }}</td>
                <td>
                    <a href="{% url 'job_detail' job.id %}" class="btn btn-sm btn-outline-primary">
                        <i class="bi bi-eye"></i> View
                    </a>
                </td>
            </tr>
            {% empty %}
            <tr>
                <td colspan="9" class="text-center text-muted py-4">
                    <i class="bi bi-inbox" style="font-size: 3rem;"></i>
                    <p class="mt-2">No jobs found. Create your first imaging job!</p>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</div>
{% endblock %}

{% block extra_scripts %}
<script>
    // WebSocket connection for real-time job updates
    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsUrl = `${protocol}//${window.location.host}/ws/job-list/`;
    let socket;
    let reconnectInterval = 3000;
    let reconnectTimer;

    function connectWebSocket() {
        socket = new WebSocket(wsUrl);

        socket.onopen = function(e) {
            console.log('WebSocket connected for job list updates');
        };

        socket.onmessage = function(e) {
            const data = JSON.parse(e.data);

            if (data.type === 'job_list_update') {
                updateJobRow(data.job);
            }
        };

        socket.onclose = function(e) {
            console.log('WebSocket closed. Reconnecting...');
            reconnectTimer = setTimeout(connectWebSocket, reconnectInterval);
        };

        socket.onerror = function(error) {
            console.error('WebSocket error:', error);
            socket.close();
        };
    }

    function updateJobRow(job) {
        const row = document.querySelector(`tr[data-job-id="${job.id}"]`);

        if (!row) {
            // Job doesn't exist in table, reload the page to show it
            location.reload();
            return;
        }

        // Update status badge
        const statusCell = row.querySelector('.job-status');
        if (statusCell) {
            let badgeClass = 'bg-secondary';
            let statusText = job.status;

            switch(job.status) {
                case 'completed':
                    badgeClass = 'bg-success';
                    statusText = 'Completed';
                    break;
                case 'in_progress':
                    badgeClass = 'bg-info';
                    statusText = 'In Progress';
                    break;
                case 'failed':
                    badgeClass = 'bg-danger';
                    statusText = 'Failed';
                    break;
                case 'queued':
                    badgeClass = 'bg-warning';
                    statusText = 'Queued';
                    break;
                default:
                    statusText = job.status.charAt(0).toUpperCase() + job.status.slice(1);
            }

            statusCell.innerHTML = `<span class="badge ${badgeClass}">${statusText}</span>`;
        }

        // Update progress bar
        const progressCell = row.querySelector('.job-progress');
        if (progressCell && job.progress_percentage !== undefined) {
            const progressBar = progressCell.querySelector('.progress-bar');
            const isInProgress = job.status === 'in_progress';

            progressBar.style.width = `${job.progress_percentage}%`;
            progressBar.setAttribute('aria-valuenow', job.progress_percentage);
            progressBar.textContent = `${job.progress_percentage}%`;

            // Add/remove animation class
            if (isInProgress) {
                progressBar.classList.add('progress-bar-striped', 'progress-bar-animated');
            } else {
                progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
            }
        }
    }

    // AJAX fallback polling
    let pollingInterval;
    let wsConnected = false;

    function startPolling() {
        if (pollingInterval) return;
        console.log('Starting AJAX polling fallback');
        pollingInterval = setInterval(fetchJobData, 5000);
    }

    function stopPolling() {
        if (pollingInterval) {
            clearInterval(pollingInterval);
            pollingInterval = null;
        }
    }

    function fetchJobData() {
        fetch('{% url "job_list_api" %}')
            .then(response => response.json())
            .then(data => {
                if (data.jobs) {
                    data.jobs.forEach(job => updateJobRow(job));
                }
            })
            .catch(error => console.error('Polling error:', error));
    }

    // Modified WebSocket handlers
    socket.onopen = function(e) {
        console.log('WebSocket connected for job list updates');
        wsConnected = true;
        stopPolling();
    };

    socket.onclose = function(e) {
        console.log('WebSocket closed. Starting polling fallback...');
        wsConnected = false;
        startPolling();
        reconnectTimer = setTimeout(connectWebSocket, reconnectInterval);
    };

    // Connect on page load
    connectWebSocket();

    // Start polling as initial fallback
    setTimeout(() => {
        if (!wsConnected) {
            startPolling();
        }
    }, 2000);

    // Cleanup on page unload
    window.addEventListener('beforeunload', function() {
        stopPolling();
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
        }
        if (socket) {
            socket.close();
        }
    });
</script>
{% endblock %}
